//In the terminal write: FreeFem++ problem_essential.edp
load "msh3"
load "medit"
load "Element_QF"

real trad = 0.75;
real alpha = 1./4;
int nlayer = 20;
int nsides = 5 * nlayer * pi * 2;
int ninter = 5 * nlayer * pi * 2 * trad / 4;

func fx = x;
func fy = y;
func fz = (z<0.5)*((2.-2.*alpha)*z*z+alpha*z) + (z>=0.5)*((2*alpha-2)*z*z+(4-3*alpha)*z+(alpha-1));

border outer(t=0, 2*pi){x=1.00*cos(t); y=1.00*sin(t); label=1;}
border inner(t=0, 2*pi){x=trad*cos(t); y=trad*sin(t);}

mesh baseh = buildmesh(outer(nsides) + inner(ninter));
plot(baseh, wait=1);

int[int] rup=[0,1],  rdown=[0,2], rmid=[1,3];

func zmin = 0;
func zmax = 1;

mesh3 Th = buildlayers(baseh, nlayer, coef=1., zbound=[zmin,zmax], labelmid=rmid, labelup=rup, labeldown=rdown, transfo=[fx, fy, fz]);

//medit("cylinder",Th,wait=1);
savemesh(Th, "mesh_utilities/problem.mesh");
//plot(Th, cmm="cylinder");

fespace Vh(Th, P2);
fespace Uh(Th, FEQF53d);

Vh fP1;
real[int] zero(Vh.ndof);
real[int] temp(Vh.ndof); 
fP1 = 0; 
zero = fP1[];
int PP = 49;
real[int, int] measures((PP+1)*(PP+1), Vh.ndof);


//Cartesian grid (we have a rectangle)
for (int ii=0; ii < Vh.ndof; ii++){
	temp = zero; 
	temp(ii) = 1; 
	fP1[] =  temp;

	for  (int pp=0; pp <= PP; pp++){ 
        for  (int qq=0; qq <= PP; qq++){  
			int index = (PP+1) * pp + qq;

			// Debugging output for indices
			//cout << "pp: " << pp << " qq: " << qq << " measures index: " << index << endl;
			//cout << "Evaluating fP1 at: (" << real(pp)/real(PP) <<  " , 0, "<< real(qq)/real(PP) << ")" << endl;
			
			measures(index, ii) = fP1(2*(real(pp)/real(PP))-1, 0, real(qq)/real(PP));
}	}	}

ofstream vvgg("mesh_utilities/xz_y.btxt", binary); vvgg << measures;

/*//Polar grid (we have a circle)
real rmax = 1.0; 
real thetamax = 2*pi;  
for (int ii=0; ii < Vh.ndof; ii++){
	temp = zero; 
	temp(ii) = 1; 
	fP1[] =  temp;

	for (int i = 0; i <= PP; i++) {  // Loop sugli angoli (theta)
        for (int j = 0; j <= PP; j++) {  // Loop sui raggi (r) 
			real r = (real(j) / real(PP)) * rmax;           // Calcola la distanza radiale
			real theta = (real(i) / real(PP)) * thetamax;  // Calcola l'angolo

			// Calcola le coordinate cartesiane (x, y) nel piano XY
            real x = r * cos(theta);
            real y = r * sin(theta);

			// Mappatura dell'indice dell'array
            int index = (PP + 1) * i + j;  // Indice unidimensionale per la griglia

			// Debugging output for indices
			//cout << "pp: " << pp << " qq: " << qq << " measures index: " << index << endl;
			//cout << "Evaluating fP1 at: (" << 2*(real(pp)/real(PP))-1 << ", "<< 2*(real(qq)/real(PP))-1 <<", 0 )" << endl;
			
			// Assegna il valore della funzione fP1 alla posizione (x, y, 0)
            measures(index, ii) = fP1(x, y, 0.95);
}	}	}

ofstream vvll("mesh_utilities/xy_z.btxt", binary); vvll << measures;*/


 