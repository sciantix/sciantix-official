//////////////////////////////////////////////////////////////////////////////////////
//       _______.  ______  __       ___      .__   __. .___________. __  ___   ___  //
//      /       | /      ||  |     /   \     |  \ |  | |           ||  | \  \ /  /  //
//     |   (----`|  ,----'|  |    /  ^  \    |   \|  | `---|  |----`|  |  \  V  /   //
//      \   \    |  |     |  |   /  /_\  \   |  . `  |     |  |     |  |   >   <    //
//  .----)   |   |  `----.|  |  /  _____  \  |  |\   |     |  |     |  |  /  .  \   //
//  |_______/     \______||__| /__/     \__\ |__| \__|     |__|     |__| /__/ \__\  //
//                                                                                  //
//  Originally developed by D. Pizzocri & T. Barani                                 //
//                                                                                  //
//  Version: 2.0                                                                    //
//  Year: 2022                                                                      //
//  Authors: D. Pizzocri, G. Zullo, G. Nicodemo                                     //
//                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////

#include "SetGPVariables.h"
#include "Simulation.h"

// -----------------------------------------------------------------------------------------------
// Functions for GPs
// -----------------------------------------------------------------------------------------------

std::vector<std::vector<double>> ReadValuesFromFile(std::ifstream& input_file) 
{
    std::vector<std::vector<double>> matrix;

    std::string line;
    while (std::getline(input_file, line)) {
        std::istringstream iss(line);
        std::vector<double> row;

        double value;
        while (iss >> value) {
            row.push_back(value);
        }

        if (!row.empty()) {
            matrix.push_back(row);
        }
    }

    return matrix;
}

double bilinearInterpolation(const std::vector<std::vector<double>>& matrix,
							const std::vector<double>& x,
                            const std::vector<double>& y,
                            double val1,
                            double val2) 
{
    // Find the index I such that val1 falls between x[I-1] and x[I]
    int I = 0;
    while (I < x.size() && x[I] < val1) {
        I++;
    }

    // Find the index J such that val2 falls between y[J-1] and y[J]
    int J = 0;
    while (J < y.size() && y[J] < val2) {
        J++;
    }

    // Bilinear interpolation
    double x1 = x[I - 1], x2 = x[I];
    double y1 = y[J - 1], y2 = y[J];

    double Q11 = matrix[I - 1][J - 1];
    double Q21 = matrix[I][J - 1];
    double Q12 = matrix[I - 1][J];
    double Q22 = matrix[I][J];

    double dx = (val1 - x1) / (x2 - x1);
    double dy = (val2 - y1) / (y2 - y1);

    double result = (1 - dx) * (1 - dy) * Q11 + dx * (1 - dy) * Q21 +
                    (1 - dx) * dy * Q12 + dx * dy * Q22;

    return result;
}

void Simulation::setGPVariables(
    int Sciantix_options[],
    double Sciantix_history[],
    double Sciantix_variables[]
)
{   
    // Loading of files generated by GPs for Xe Diffusion Coefficient
    if (input_variable["iFissionGasDiffusivity"].getValue() == 90)
    {
        std::ifstream input_fileU1(TestPath + "UpdatedCorrelation_XeDiffusionCoefficient.txt");
        std::ifstream input_fileS1(TestPath + "GPregression/Results/StandardDeviation_XeDiffusionCoefficient.txt");
        std::vector<std::vector<double>> matrixUpdateXeDiffusionCoefficient = ReadValuesFromFile(input_fileU1);
        std::vector<std::vector<double>> matrixStdDevXeDiffusionCoefficient = ReadValuesFromFile(input_fileS1);

        // Generate vectors
        std::vector<double> TT_vector(100);
        std::vector<double> FF_vector(100);

        double start_TT = 4.0;
        double end_TT = 9.0;
        double start_FF = 18.0;
        double end_FF = 22.0;

        double step_TT = (end_TT - start_TT) / 99;
        double step_FF = (end_FF - start_FF) / 99;

        // Generate values for TT_plot
        for (int i = 0; i < 100; ++i) {
            TT_vector[i] = start_TT + i * step_TT;
        }

        // Generate values for F_plot
        for (int i = 0; i < 100; ++i) {
            FF_vector[i] = start_FF + i * step_FF;
        }

        // Perform the interpolation
        double XeDiffusionCoefficientGP = bilinearInterpolation(matrixUpdateXeDiffusionCoefficient, TT_vector, FF_vector, pow(10,4)/history_variable["Temperature"].getFinalValue(),
                                                                log10(history_variable["Fission rate"].getFinalValue()));

        XeDiffusionCoefficientGP = pow(10, XeDiffusionCoefficientGP);

        sciantix_variable["Diffusion coefficient"].setFinalValue(XeDiffusionCoefficientGP);

    }
    
}