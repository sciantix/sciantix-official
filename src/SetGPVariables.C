//////////////////////////////////////////////////////////////////////////////////////
//       _______.  ______  __       ___      .__   __. .___________. __  ___   ___  //
//      /       | /      ||  |     /   \     |  \ |  | |           ||  | \  \ /  /  //
//     |   (----`|  ,----'|  |    /  ^  \    |   \|  | `---|  |----`|  |  \  V  /   //
//      \   \    |  |     |  |   /  /_\  \   |  . `  |     |  |     |  |   >   <    //
//  .----)   |   |  `----.|  |  /  _____  \  |  |\   |     |  |     |  |  /  .  \   //
//  |_______/     \______||__| /__/     \__\ |__| \__|     |__|     |__| /__/ \__\  //
//                                                                                  //
//  Originally developed by D. Pizzocri & T. Barani                                 //
//                                                                                  //
//  Version: 2.0                                                                    //
//  Year: 2022                                                                      //
//  Authors: D. Pizzocri, G. Zullo, G. Nicodemo                                     //
//                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////

#include "SetGPVariables.h"

#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <cmath>

// -----------------------------------------------------------------------------------------------
// Functions for GPs
// -----------------------------------------------------------------------------------------------

std::vector<std::vector<double>> ReadValuesFromFile(std::ifstream& input_file) 
{
    std::vector<std::vector<double>> matrix;

    std::string line;
    while (std::getline(input_file, line)) {
        std::istringstream iss(line);
        std::vector<double> row;

        double value;
        while (iss >> value) {
            row.push_back(value);
        }

        if (!row.empty()) {
            matrix.push_back(row);
        }
    }

    return matrix;
}

double linearInterpolation(const std::vector<std::vector<double>>& matrix,
							const std::vector<double>& x,
                            double val1)
{
    // Find the index I such that val1 falls between x[I-1] and x[I]
    int I = 0;
    while (I < x.size() && x[I] < val1) {
        I++;
    }

    // Linear interpolation
    double x1 = x[I - 1], x2 = x[I];

    double Q1 = matrix[I - 1][0];
    double Q2 = matrix[I][0];

    // linear interpolation: y = (y2-y1)/(x2-x1)*(x-x1) + y1
    // corresponds to: result = (Q2-Q1)/(x2-x1)*(val1-x1) + Q1
    // result = (Q2-Q1)*dx + Q1

    double dx = (val1 - x1) / (x2 - x1);

    double result = (1 - dx)*Q1 + dx * Q2;

    return result;
}

double bilinearInterpolation(const std::vector<std::vector<double>>& matrix,
							const std::vector<double>& x,
                            const std::vector<double>& y,
                            double val1,
                            double val2)
{
    // Find the index I such that val1 falls between x[I-1] and x[I]
    int I = 0;
    while (I < x.size() && x[I] < val1) {
        I++;
    }

    // Find the index J such that val2 falls between y[J-1] and y[J]
    int J = 0;
    while (J < y.size() && y[J] < val2) {
        J++;
    }

    // Bilinear interpolation
    double x1 = x[I - 1], x2 = x[I];
    double y1 = y[J - 1], y2 = y[J];

    double Q11 = matrix[I - 1][J - 1];
    double Q21 = matrix[I][J - 1];
    double Q12 = matrix[I - 1][J];
    double Q22 = matrix[I][J];

    double dx = (val1 - x1) / (x2 - x1);
    double dy = (val2 - y1) / (y2 - y1);

    double result = (1 - dx) * (1 - dy) * Q11 + dx * (1 - dy) * Q21 +
                    (1 - dx) * dy * Q12 + dx * dy * Q22;

    return result;
}

void SetGPVariables()
{

    // Loading of files generated by GPs for Xe Diffusion Coefficient
    if (int(input_variable[iv["iFGDiffusionCoefficient"]].getValue()) == 90)
    {
        std::ifstream input_fileU1("../GPVariables/UpdatedCorrelation_XeDiffusionCoefficient.txt");
        std::ifstream input_fileS1("../GPVariables/StandardDeviation_XeDiffusionCoefficient.txt");
        std::vector<std::vector<double>> matrixUpdateXeDiffusionCoefficient = ReadValuesFromFile(input_fileU1);
        std::vector<std::vector<double>> matrixStdDevXeDiffusionCoefficient = ReadValuesFromFile(input_fileS1);

        // Generate vectors
        std::vector<double> TT_vector(100);
        std::vector<double> FF_vector(100);

        double start_TT = 4.0;
        double end_TT = 9.0;
        double start_FF = 18.0;
        double end_FF = 22.0;

        double step_TT = (end_TT - start_TT) / 99;
        double step_FF = (end_FF - start_FF) / 99;

        // Generate values for TT_plot
        for (int i = 0; i < 100; ++i) {
            TT_vector[i] = start_TT + i * step_TT;
        }

        // Generate values for F_plot
        for (int i = 0; i < 100; ++i) {
            FF_vector[i] = start_FF + i * step_FF;
        }

        // Perform the interpolation
        double XeDiffusionCoefficientGP = bilinearInterpolation(matrixUpdateXeDiffusionCoefficient, TT_vector, FF_vector, pow(10,4)/history_variable[hv["Temperature"]].getFinalValue(),
                                                                log10(history_variable[hv["Fission rate"]].getFinalValue()));

        XeDiffusionCoefficientGP = pow(10, XeDiffusionCoefficientGP);

        sciantix_variable[sv["Diffusion coefficient"]].setFinalValue(XeDiffusionCoefficientGP);

    }


        // Loading of files generated by GPs for Vented Fraction
    if ((sciantix_variable[sv["Intergranular fractional coverage"]].getFinalValue())) // to be changed
    {
        std::ifstream input_fileU1("../GPVariables/UpdatedCorrelation_VentedFraction.txt");
        std::ifstream input_fileS1("../GPVariables/StandardDeviation_VentedFraction.txt");
        std::vector<std::vector<double>> matrixUpdateVentedFraction = ReadValuesFromFile(input_fileU1);
        std::vector<std::vector<double>> matrixStdDevVentedFraction = ReadValuesFromFile(input_fileS1);

        // Generate vectors
        std::vector<double> Fc_vector(100);

        double start_Fc = 0;
        double end_Fc = 52;

        double step_Fc = (end_Fc - start_Fc) / 99;
        
        // Generate values for Fc_plot
        for (int i = 0; i < 100; ++i) {
            Fc_vector[i] = start_Fc + i * step_Fc;
        }

        // Perform the interpolation
        double VentedFractionGP0 = linearInterpolation(matrixUpdateVentedFraction, Fc_vector, 100*sciantix_variable[sv["Intergranular fractional coverage"]].getInitialValue());
        VentedFractionGP0 = VentedFractionGP0/100;

        double VentedFractionGP = linearInterpolation(matrixUpdateVentedFraction, Fc_vector, 100*sciantix_variable[sv["Intergranular fractional coverage"]].getFinalValue());
        VentedFractionGP = VentedFractionGP/100;

        sciantix_variable[sv["Intergranular vented fraction"]].setInitialValue(VentedFractionGP0);
        sciantix_variable[sv["Intergranular vented fraction"]].setFinalValue(VentedFractionGP);


    }
    
}
